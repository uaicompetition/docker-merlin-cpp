<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Merlin: Description</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Merlin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_README.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Description </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="classMerlin.html">Merlin</a> is a standalong solver written in <code>C++</code> that implements state-of-the-art exact and approximate algorithms for probabilistic inference over graphical models including both directed and undirected models (e.g., Bayesian networks, Markov Random Fields). It can be used for many applications and research in bioinformatics, computer vision, or speech and language processing to name a few. <a class="el" href="classMerlin.html">Merlin</a> supports the most common probabilistic inference tasks such as computing the partition function or probability of evidence (PR), posterior marginals (MAP), as well as MAP (also known as maximum aposteriori or most probable explanation) and marginal MAP configurations.</p>
<p><a class="el" href="classMerlin.html">Merlin</a> implements the classic Loopy Belief Propagation (LBP) algorithm as well as more advanced generalized belief propagation algorithms such as Iterative Join-Graph Propagation (IJGP) and Weighted Mini-Bucket Elimination (WMB). The default algorithm for computing all four probabilistic inference tasks (PR, MAR, MAP, MMAP) is WMB(i). The algorithm is parameterized by an i-bound that allows for a controllable tradeoff between accuracy of the results and the computational cost. Larger values of the i-bound typically yield more accurate results but it takes more time and memory to compute them. Selecting a large enough i-bound allows for exact inference (i.e., i-bound equal to the treewidth of the model). For relatively small i-bounds <a class="el" href="classMerlin.html">Merlin</a> performs approximate inference.</p>
<h1>API</h1>
<h2><a class="el" href="classMerlin.html">Merlin</a> API</h2>
<p>Class <code><a class="el" href="classMerlin.html">Merlin</a></code> defined in <code><a class="el" href="merlin_8h.html" title="Merlin inference engine interface. ">merlin.h</a></code> header exposes most of the functionality of the solver. A graphical model is a collection of factors (or positive real-valued functions) defined over subsets of variables. Variables are assumed to be indexed from <code>0</code>.</p>
<h3>Methods</h3>
<pre class="fragment">    bool read_model(const char* f)
</pre><p> This method loads the graphical model from a file which is specified using the UAI format (see also the File Formats section). Returns <code>true</code> if successful and <code>false</code> otherwise. </p><pre class="fragment">    bool read_evidence(const char* f)
</pre><p> This method loads the evidence variables and their corresponding observed values from a file which is also specified using the UAI format. Returns <code>true</code> if successful, and <code>false</code> otherwise. </p><pre class="fragment">    bool read_query(const char* f)
</pre><p> This method loads the query variables from a file specified using the UAI format. The query variables (also known as MAX of MAP variables) are only specific to Marginal MAP (MMAP) inference tasks. Returns <code>true</code> if successful, and <code>false</code> otherwise. </p><pre class="fragment">    bool set_task(size_t t)
</pre><p> This method sets the probabilistic inference task to be solved. The possible values for the <code>t</code> parameter are:</p><ul>
<li><code>MERLIN_TASK_PR</code> : Partition function (probability of evidence)</li>
<li><code>MERLIN_TASK_MAR</code> : Posterior marginals (given evidence)</li>
<li><code>MERLIN_TASK_MAP</code> : Maximum aposteriori (given evidence)</li>
<li><code>MERLIN_TASK_MMAP</code> : Marginal MAP (given evidence) <pre class="fragment">  bool set_algorithm(size_t a)
</pre> This method sets the the algorithm to be used when solving the selected probabilistic inference task. The possible values for the <code>a</code> parameter are:</li>
<li><code>MERLIN_ALGO_GIBBS</code> : Gibbs sampling</li>
<li><code>MERLIN_ALGO_LBP</code> : Loopy belief propagation</li>
<li><code>MERLIN_ALGO_IJGP</code> : Iterative join graph propagation</li>
<li><code>MERLIN_ALGO_JGLP</code> : Join graph linear programming</li>
<li><code>MERLIN_ALGO_WMB</code> : Weighted mini-bucket elimination</li>
<li><code>MERLIN_ALGO_AOBB</code> : AND/OR branch and bound search (not implemented yet)</li>
<li><code>MERLIN_ALGO_AOBF</code> : Best-first AND/OR search (not implemented yet)</li>
<li><code>MERLIN_ALGO_RBFAOO</code> : Recursive best-first AND/OR search (not implemented yet) <pre class="fragment">  void set_param_ibound(size_t ibound)
</pre> This method sets the i-bound parameter which is used by the following algorithms: <code>WMB</code>, <code>IJGP</code>, <code>JGLP</code> (as well as search based ones <code>AOBB</code>, <code>AOBF</code>, and <code>RBFAOO</code>). The default value is <code>4</code>. <pre class="fragment">    void set_param_iterations(size_t iter)
</pre> This method sets the number of iterations to be executed by the inference algorithm. The parameter is specific to the following algorithms: <code>WMB</code>, <code>IJGP</code>, <code>JGLP</code>, and <code>LBP</code>. The default value is <code>100</code>. For Gibbs sampling consider runnig several thousands of iterations. <pre class="fragment">    void set_param_samples(size_t s)
</pre> This method sets the number of samples to be generated in each iteration of the <code>GIBBS</code> sampling algorithm. The default value is <code>100</code>. <pre class="fragment">    void run()
</pre> This method runs the inference algorithm for the selected task on the input graphical model and evidence (if any). The output is generated into a file specified using the UAI format. The name of the output file is obtained from the input file augmented with the <code>task.out</code> suffix, where <code>task</code> corresponds to one of the follwing: <code>PR</code>, <code>MAR</code>, <code>MAP</code>, or <code>MMAP</code>.</li>
</ul>
<h1>Source Code</h1>
<p>The source code is organized along the following directory structure and requires a standard GNU build using the GNU Autotools toolchain.</p>
<ul>
<li><code>src/</code> - contains the source (.cpp) files</li>
<li><code>src/include/</code> - contains the header (.h) files</li>
<li><code>data/</code> - contains several example graphical models</li>
<li><code>doc/</code> - contains the documentation</li>
</ul>
<h1>Build</h1>
<p>The simplest way to compile the solver is to import the Eclipse project into Eclipse CDT and compile it in Release or Debug mode.</p>
<h2>Building the Documentation</h2>
<p><a class="el" href="classMerlin.html">Merlin</a> uses Doxygen to build automatically the reference manual of the library, and supports both <code>html</code> and <code>latex</code> (see the corresponding <code>doc/html</code> and <code>doc/latex</code> subfolders).</p>
<p>To build the entire documentation, simply run <code>doxygen merlin.doxygen</code> in the main folder <code>merlin/</code>. To generate the pdf run <code>make all</code> in the <code>doc/latex</code> subfolder).</p>
<h1>File Formats</h1>
<h2>Input File Format</h2>
<p><a class="el" href="classMerlin.html">Merlin</a> uses a simple text file format which is specified below to describe a problem instances (i.e., graphical model). The format is identical to the one used during the UAI Inference competitions.</p>
<h3>Structure</h3>
<p>The input file format consists of the following two parts, in that order: </p><pre class="fragment">    &lt;Preamble&gt;
    &lt;Factors&gt;
</pre><p>The contents of each section (denoted &lt; …&gt;=""&gt; above) are described in the following:</p>
<h4>Preamble</h4>
<p>The description of the format will follow a simple Markov network with three variables and two functions. A sample preamble for such a network is: </p><pre class="fragment">    MARKOV
    3
    2 2 3
    2
    2 0 1
    2 1 2
</pre><p>The preamble starts with one line denoting the type of network. Generally, this can be either BAYES (if the network is a Bayesian network) or MARKOV (in case of a Markov network).</p>
<p>The second line contains the number of variables.</p>
<p>The third line specifies the cardinalities of each variable, one at a time, separated by a whitespace (note that this implies an order on the variables which will be used throughout the file).</p>
<p>The fourth line contains only one integer, denoting the number of cliques in the problem. Then, one clique per line, the scope of each clique is given as follows: The first integer in each line specifies the number of variables in the clique, followed by the actual indexes of the variables. The order of this list is not restricted (for Bayesian networks we assume that the child variable of the clique is the last one). Note that the ordering of variables within a factor will follow the order provided here.</p>
<p>Referring to the example above, the first line denotes the Markov network, the second line tells us the problem consists of three variables, let's refer to them as <code>X</code>, <code>Y</code>, and <code>Z</code>. Their cardinalities are <code>2</code>, <code>2</code>, and <code>3</code> respectively (from the third line). Line four specifies that there are 2 cliques. The first clique is <code>X,Y</code>, while the second clique is <code>Y,Z</code>. Note that variables are indexed starting with <code>0</code>.</p>
<h4>Factors</h4>
<p>Each factor is specified by giving its full table (i.e, specifying a non-negative real value for each assignment). The order of the factors is identical to the one in which they were introduced in the preamble, the first variable has the role of the 'most significant' digit. For each factor table, first the number of entries is given (this should be equal to the product of the domain sizes of the variables in the scope). Then, one by one, separated by whitespace, the values for each assignment to the variables in the factor's scope are enumerated. Tuples are implicitly assumed in ascending order, with the last variable in the scope as the <code>least significant</code>. To illustrate, we continue with our Markov network example from above, let's assume the following conditional probability tables: </p><pre class="fragment">    X | P(X)  
    0 | 0.436 
    1 | 0.564 

    X   Y |  P(Y,X)
    0   0 |  0.128
    0   1 |  0.872
    1   0 |  0.920
    1   1 |  0.080

    Y   Z |  P(Z,Y)
    0   0 |  0.210
    0   1 |  0.333
    0   2 |  0.457
    1   0 |  0.811
    1   1 |  0.000
    1   2 |  0.189
</pre><p>Then we have the corresponding file content: </p><pre class="fragment">    2
     0.436 0.564

    4
     0.128 0.872
     0.920 0.080

    6
     0.210 0.333 0.457
     0.811 0.000 0.189
</pre><p>Note that line breaks and empty lines are effectively just a whitespace, exactly like plain spaces “ ”. They are used here to improve readability.</p>
<h2>Evidence File Format</h2>
<p>Evidence is specified in a separate file. The evidence file consists of a single line. The line will begin with the number of observed variables in the sample, followed by pairs of variable and its observed value. The indexes correspond to the ones implied by the original problem file.</p>
<p>If, for our example Markov network, <code>Y</code> has been observed as having its first value and <code>Z</code> with its second value, the evidence file would contain the following line: </p><pre class="fragment">    2 1 0 2 1
</pre><h2>Query File Format</h2>
<p>Query variables for Marginal MAP inference are specified in a separate file. The query file consists of a single line. The line will begin with the number of query variables, followed by the indexes of the query variables. The indexes correspond to the ones implied by the original problem file.</p>
<p>If, for our example Markov network, we want to use <code>Y</code> as the query variable the query file would contain the following line: </p><pre class="fragment">    1 1
</pre><h2>Output File Format</h2>
<p>The first line must contain only the task solved: <code>PR|MAP|MAR|MMAP</code>. The rest of the file will contain the solution for the task. Solvers can write more then one solution by writing <code>-BEGIN-</code> at the head of the new solution. In the example below the task we choose is <code>PR</code>. We have two solutions. The format of the <code>&lt;SOLUTION&gt;</code> part will be described below. </p><pre class="fragment">    PR
    &lt;SOLUTION&gt;
    -BEGIN-
    &lt;SOLUTION&gt;
</pre><p>The solution format are as follows depending on the task:</p>
<h3>Partition function <code>PR</code></h3>
<p>Line with the value of the log10 of the partition function. For example, an approximation <code>log10 Pr(e) = -0.2008</code>which is known to be an upper bound may have a solution line: </p><pre class="fragment">    -0.2008
</pre> <h3>Maximum aposteriori <code>MAP</code></h3>
<p>A space separated line that includes:</p><ul>
<li>the number <code>n</code> of model variables, and</li>
<li>the MAP instantiation, a list of value indices for all <code>n</code> variables.</li>
</ul>
<p>For example, an input model with 3 binary variables may have a solution line: </p><pre class="fragment">    3 0 1 0
</pre><h3>Marginals <code>MAR</code></h3>
<p>A space separated line that includes:</p><ul>
<li>the number of variables <code>n</code> in the model, and</li>
<li>a list of marginal approximations of all the variables. For each variable its cardinality is first stated, then the probability of each state is stated. The order of the variables is the same as in the model, all data is space separated.</li>
</ul>
<p>For example, a model with <code>3</code> variables, with cardinalities of <code>2</code>, <code>2</code>, <code>3</code> respectively. The solution might look like this: </p><pre class="fragment">    3 2 0.1 0.9 2 0.3 0.7 3 0.2 0.2 0.6
</pre><h3>Marginal MAP <code>MMAP</code></h3>
<p>A space separated line that includes:</p><ul>
<li>the number <code>q</code> of query (or MAP) variables, and</li>
<li>their most probable instantiation, a list of variable value pairs for all <code>q</code> variables.</li>
</ul>
<p>For example, if the solution is an assignment of <code>0</code>, <code>1</code> and <code>0</code> to three query variables indexed by <code>2</code> <code>3</code> and <code>4</code> respectively, the solution will look as follows: </p><pre class="fragment">    3 2 0 3 1 4 0 </pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 21 2018 12:45:43 for Merlin by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
